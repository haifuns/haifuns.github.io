<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://haif-cloud.oss-cn-beijing.aliyuncs.com/img/weixing.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"haif.fun","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="网络分区网络分区意义RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 R">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ 网络分区&amp;扩展">
<meta property="og:url" content="https://haif.fun/2020/12/26/rabbitmq-4/index.html">
<meta property="og:site_name" content="With Silence.">
<meta property="og:description" content="网络分区网络分区意义RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 R">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png">
<meta property="og:image" content="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition2.png">
<meta property="article:published_time" content="2020-12-26T09:00:00.000Z">
<meta property="article:modified_time" content="2020-12-26T09:12:22.456Z">
<meta property="article:author" content="HAIF.">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png">

<link rel="canonical" href="https://haif.fun/2020/12/26/rabbitmq-4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RabbitMQ 网络分区&扩展 | With Silence.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">With Silence.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-info-circle fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-reading">

    <a href="/reading/" rel="section"><i class="fa fa-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://haif.fun/2020/12/26/rabbitmq-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="HAIF.">
      <meta itemprop="description" content="山行野宿， 孤身万里。<br/>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="With Silence.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ 网络分区&扩展
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-26 17:00:00 / 修改时间：17:12:22" itemprop="dateCreated datePublished" datetime="2020-12-26T17:00:00+08:00">2020-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">消息中间件</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/26/rabbitmq-4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/26/rabbitmq-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h1><h2 id="网络分区意义"><a href="#网络分区意义" class="headerlink" title="网络分区意义"></a>网络分区意义</h2><p>RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题。RabbitMQ 3.1 版本开始会自动探测网络分区，并且提供了相应的配置来解决这个问题。</p>
<p>当一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关。如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。当然也会有一些其他未知的、怪异的事情发生。当网络恢复时，网络分区的状态还是会保持，除非采取了一些措施去解决它。</p>
<p>RabbitMQ 网络分区带来的影响大多是负面的，极端情况下不仅会造成数据丢失，还会影响服务的可用性。那为什么RabbitMQ 还要引入网络分区的设计理念呢？其中一个原因就与它本身的数据一致性复制原理有关，RabbitMQ 采用的镜像队列是一种环形的逻辑结构 ，如下图所示：</p>
<a id="more"></a>

<p><img data-src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png" alt="image"></p>
<p>图中为某队列配置了4 个镜像，其中A 节点作为 master 节点，其余B、C、D 节点为 slave 节点，4 个镜像节点组成一个环形结构。</p>
<p>假如需要确认(ack)一条消息，先会在A 节点即master 节点上执行确认命令，之后转向B 节点，然后是C 节点，最后由D 将执行操作返回给A 节点，这样才真正确认了一条消息，之后才可以继续相应的处理。</p>
<p>这种复制原理与ZooKeeper 的Quorum 原理不同，它可以保证更强的一致性。在这种一致性数据模型下，如果出现网络波动或者网络故障等异常情况，那么整个数据链的性能就会大大降低。如果C 节点网络异常，那么整个 A -&gt; B -&gt; C -&gt; D -&gt; A 数据链就会被阻塞，继而相关服务也会被阻塞，所以这里就需要引入网络分区来将异常的节点剥离出整个分区，以确保 RabbitMQ 服务的可用性及可靠性。等待网络恢复之后，可以进行相应的处理来将此前的异常节点加入集群中。</p>
<h2 id="网络分区判定"><a href="#网络分区判定" class="headerlink" title="网络分区判定"></a>网络分区判定</h2><p>RabbitMQ 集群节点内部通信端口默认为25672 ，两两节点之间都会有信息交互，如果某节点出现网络故障，或者是端口不通，会致使与此节点的交互出现中断，这里就会有个超时判定机制，继而判定网络分区。</p>
<p>对于网络分区的判定是与 net_ticktime 参数息息相关的，此参数默认值为60 秒。注意与heartbeat_time 的区别heartbeat_time 是指客户端与 RabbitMQ 服务之间通信的心跳时间，针对 5672 端口而言。如果发生超时则会有 net_tick_timeout 的信息报出RabbitMQ 集群内部的每个节点之间会每隔四分之一的 net_ticktime 次应答(tick)。如果有任何数据被写入节点中，则此节点被认为已经被应答(ticked)了。如果连续4 次，某节点都没有被 ticked，则可以判定此节点已处于 “down” 状态，其余节点可将此节点剥离出当前分区。</p>
<p>将连续4 次的 tick 时间记为 T，那么T 的取值范围为 <code>0.75 * net_ticktime &lt; T &lt; 1.25 * net_ticktime</code>。下图可以形象地描绘出这个取值范围的缘由：</p>
<p><img data-src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition2.png" alt="image"></p>
<p>图中每个节点代表一次 tick 判定的时间戳，在2 个临界值 0.75  * net_ticktime 和<br>1.25 * net_ticktime 之间可以连续执行4 次的 tick 判定。默认情况下，在 45s &lt; T &lt; 75s 之间会判定出net_tick_timeout。</p>
<p>RabbtMQ 不仅会将队列、交换器及绑定等信息存储在 Mnesia 数据库中，而且许多围绕网络分区的一些细节也都和这个 Mneia 的行为相关。如果一个节点不能在T 时间连上另一个节点，那么 Mnesia 通常认为这个节点己经挂了，就算之后两个节点又重新恢复了内部通信，但是这两个节点都会认为对方已经挂了，Mnesia 此时认定了发生网络分区的情况。这些会被记录到RabbitMQ 的服务日志之中如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mnesia('rabbit@node1'): ** ERROR ** mnesia event got</span><br><span class="line">{inconsistent_database, running_partitioned_network, 'rabbit@node2'}</span><br></pre></td></tr></tbody></table></figure>
<p>除了通过查看 RabbitMQ 服务日志的方式，还有以下3 种方法可以查看是否出现网络分区：</p>
<ol>
<li>采用 rabbitmqctl 工具来查看，即采用<code>rabbitmqctl cluster_status</code>，通过这条命令可以看到集群相关信息，未发生网络分区时的情形举例如下：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]},</span><br><span class="line">{running_nodes, [rabbit@node2,rabbit@node3,rabbit@node1]},</span><br><span class="line">{cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;},</span><br><span class="line">{partitio, []}]</span><br></pre></td></tr></tbody></table></figure>
由上面的信息可知，集群中一共有3 个节点，分别为rabbit@node1、rabbit@node2、rabbit@node3。在partitions这一项中没有相关记录，则说明没有产生网络分区。如果partitions 项中有相关容，则说明产生了网络分区，例如：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]},</span><br><span class="line">{running_nodes, [rabbit@node3,rabbit@node1]},</span><br><span class="line">{cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;},</span><br><span class="line">{partitions, [{rabbit@node3,[rabbit@node2]},{rabbit@node1,[rabbit@node2]}]}]</span><br></pre></td></tr></tbody></table></figure>
上面partitions 项中的内容表示：</li>
</ol>
<ul>
<li>rabbit@node3与rabbit@node2 发生了分区，即 {rabbit@node3,[rabbit@node2]}</li>
<li>rabbit@node1与rabbit@node2 发生了分区，即 {rabbit@node1,[rabbit@node2]}</li>
</ul>
<ol start="2">
<li>通过 Web 管理界面的方式查看。如果发生了网络分区页面会出现警告。推荐采用这种方式来检测是否发生了网络分区。</li>
<li>通过 HTTP API 的方式调取节点信息来检测是否发生网络分区，比如通过 curl 命令来调取节点信息：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -u root:root123 -H "content-type:application/json" -X GET http://localhost:15672/api/nodes</span><br></pre></td></tr></tbody></table></figure>
<h2 id="模拟网络分区"><a href="#模拟网络分区" class="headerlink" title="模拟网络分区"></a>模拟网络分区</h2></li>
</ol>
<p>正常情况下，很难观察到 RabbitMQ 网络分区的发生。为了更好地理解网络分区，需要采取某些手段将其模拟出来，以便对其进行相应的分析处理，进而在实际应用环境中遇到类似情形可以处理游刃有余。往长远方面讲，也可以采取一些要的手段去规避网络分区的发生，或者可以监控网络分区以及准备相关的处理预案。</p>
<p>模拟网络分区的方式有多种，主要分为以下三大类:</p>
<ul>
<li>iptables 封禁/解封 IP 地址或者端口号；</li>
<li>关闭/开启网卡；</li>
<li>挂起/恢复操作系统；</li>
</ul>
<h2 id="网络分区的影响"><a href="#网络分区的影响" class="headerlink" title="网络分区的影响"></a>网络分区的影响</h2><h3 id="未配置镜像"><a href="#未配置镜像" class="headerlink" title="未配置镜像"></a>未配置镜像</h3><p>node1、node2、node3 三个节点组成一个RabbitMQ 集群，且在这三个节点中分别创建queue1、queue2、queue3这三个队列，并且相应的交换器与绑定关系如下：</p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>交换器</th>
<th>绑定</th>
<th>队列</th>
</tr>
</thead>
<tbody><tr>
<td>node1</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>node2</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>node3</td>
<td>exchange</td>
<td>rk3</td>
<td>queue3</td>
</tr>
</tbody></table>
<p><strong>客户端分别连接node1 和node2 并分别向/从queue1 和queue2 发送/消费消息</strong></p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>节点名称</th>
<th>交换器</th>
<th>绑定</th>
<th>队列</th>
</tr>
</thead>
<tbody><tr>
<td>client1(producer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>client2(producer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>client3(consumer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>client4(consumer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
</tbody></table>
<p>在发生网络分区后，node1、node2 存在于两个不同的分区之中，对于消息生产端client1、client2 而言，没有任何异常，消息正常发送也没有消息丢失。消费端client3、client4 也都能正常消费，无任何异常发生。</p>
<p><strong>客户端分别连接node1 和node2 并分别向/从queue2 和queue1 发送/消费消息</strong></p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>节点名称</th>
<th>交换器</th>
<th>绑定</th>
<th>队列</th>
</tr>
</thead>
<tbody><tr>
<td>client1(producer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>client2(producer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>client3(consumer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>client4(consumer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
</tbody></table>
<p>在发生网络分区后，node1、node2 存在于两个不同的分区之中，client1 不能将消息正确地送达到queue2 ，同样client2 不能将消息送达到queue1 中。如果客户端中设置了ReturnListener 来监听 Basic.Return 的信息，并附带有消息重传机制，那么在整个网络分区前后的过程中可以保证发送端的消息不丢失。</p>
<p>在网络分区之前queue1 进程存在于node1 节点中，queue2 进程存在于node2 节点中。<br>在网络分区之后，在node1 所在的分区并不会创建新的queue2 进程，同样在node2 所在的分区也不会创建新的queue1 的进程。这样在网络分区发生之后，虽然可以通过 <code>rabbitmqctl list_queues name</code> 命令在node1 节点上查看到queue2，但是在node1 上已经没有真实的queue2 进程的存在。</p>
<p>client1 将消息发往交换器exchange 之后并不能路由到queue2 中，因此消息也就不能存储。如果客户端没有设置mandatory 参数并且没有通过ReturnListener 进行消息重试(或者其他措施)来保障消息可靠性，那么在发送端就会有消息丢失。</p>
<p>对于消费端client3、client4，客户端没有异常报错，且可以消费到相关数据，但是此时会有一些怪异的现象发生，比如对于已消费消息的ack 失效。在从网络分区中恢复之后，数据不会丢失。</p>
<p>如果分区之后，重启client3 或者有个新的客户端client5 连接node1 IP 来消费queue2 则会报错。</p>
<p><strong>小结</strong></p>
<p>对于未配置镜像的集群，网络分区发生之后，队列也会伴随着宿主节点而分散在各自的分区之中。对于消息发送方而言，可以成功发送消息，但是会有路由失败的现象，要需要配合mandatory 等机制保障消息的可靠性。对于消息消费方来说，有可能会有诡异、不可预知的现象发生，比如对于已消费消息的ack 会失效。如果网络分区发生之后，客户端与某分区重新建立通信链路，其分区中如果没有相应的队列进程，则会有异常报出。如果从网络分区中恢复之后，数据不会丢失，但是客户端会重复消费。</p>
<h3 id="已配置镜像"><a href="#已配置镜像" class="headerlink" title="已配置镜像"></a>已配置镜像</h3><p>如果集群中配置了镜像队列，那么在发生网络分区时，情形比未配置镜像队列的情况复杂得多，尤其是发生多个网络分区的时候。这里先简单地从3 个节点分裂成2 个网络分区的情形展开讨论。如前文所述，集群中有node1、node2、node3 三个节点，分别在这些节点上创建队列queue1、queue2、queue3 并配置镜像队列。采用iptables 的方式将集群模拟分裂[node1,node3] [node2] 这两个网络分区。</p>
<p>镜像队列的相关配置可以参考如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ha-mode:exactly </span><br><span class="line">ha-param:2 </span><br><span class="line">ha-sync-mode:automatic</span><br></pre></td></tr></tbody></table></figure>
<p>首先来分析第一种情况。如下表示，3 个队列的master 镜像和slave 镜像分别做相应分布。</p>
<p>分区之前：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>node3</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node2</td>
</tr>
</tbody></table>
<p>分区之后：</p>
<p>[node1,node3]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node3</td>
<td>node1</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<p>在发生网络分区之后 [node1,node3] 分区中的队列有了新的部署。除了queue1 未发生改变，queue2 于原宿主节点node2 被剥离当前分区，那么node3 提升为master ，同时选择node1 作为slave 。在queue3 重新选择node1 作为其新的slave。</p>
<p>[node2]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>[]</td>
</tr>
<tr>
<td>queue3</td>
<td>node2</td>
<td>[]</td>
</tr>
</tbody></table>
<p>对于[node2] 分区而言，queue2、queue3的分布比较容易理解，此分区中只有一个节点，所有slave 列为空。但是对于queue1而言，其部署还是和分区前如出一辙。不管是在网络分区前，还是在网络分区之后，再或者是又从网络分区中恢复，对于queue1而言生产和消费消息都不会受到任何的影响，就如未发生过网络分区一样。对于队列queue2、queue3 情形可以参考上面未配置镜像的相关细节，从网络分区中恢复(即恢复成之前的[node1,node2,node3] 组成的完整分区)之后可能会有数据丢失。</p>
<p>再考虑另一种情形，分区之前如下所示：</p>
<p>分区之前：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node2</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>node3</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<p>分区之后：</p>
<p>[node1,node3]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node3</td>
<td>node1</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<p>[node2]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node2</td>
<td>[]</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>[]</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<h2 id="手动处理网络分区"><a href="#手动处理网络分区" class="headerlink" title="手动处理网络分区"></a>手动处理网络分区</h2><p>为了从网络分区中恢复，首先需要挑选一个信任分区，这个分区才有决定Mnesia 内容的权限，发生在其他分区的改变将不会被记录到Mnesia 中而被直接丢弃。在挑选完信任分区之后，重启非信任分区中的节点，如果此时还有网络分区的告警，紧接着重启信任分区中的节点。</p>
<p>这里有3 个要点需要详细阐述：</p>
<ul>
<li>如何挑选信任分区？</li>
<li>如何重启节点？</li>
<li>重启的顺序有何考究？</li>
</ul>
<h3 id="如何挑选信任分区？"><a href="#如何挑选信任分区？" class="headerlink" title="如何挑选信任分区？"></a>如何挑选信任分区？</h3><p>挑选信任分区一般可以按照这几个指标进行：</p>
<ul>
<li>分区中要有disc 节点；</li>
<li>分区中的节点数最多；</li>
<li>分区中的队列数最多；</li>
<li>分区中的客户端连接数最多；</li>
</ul>
<p>优先级从前到后，例如信任分区中要有disc 节点；如果有两个或者多个分区满足，则挑选节点数最多的分区作为信任分区；如果又有两个或者多个分区满足，那么挑选队列数最多的分区作为信任分区。依次类推如果有两个或者多个分区对于这些指标都均等，那么可以随机挑选一个分区。</p>
<h3 id="如何重启节点？"><a href="#如何重启节点？" class="headerlink" title="如何重启节点？"></a>如何重启节点？</h3><p>RabbitMQ 中有两种重启方式：</p>
<ul>
<li>使用 <code>rabbitmqctl stop</code> 命令关闭，然后再用 <code>rabbitmq-server -detached</code>命令启动</li>
<li>使用 <code>rabbitmqctl stop_app</code> 关闭，然后使用 <code>rabbitmqctl start_app</code>命令启动。</li>
</ul>
<p>第一种方式需要同时重启erlang 虚拟机和RabbitMQ 应用，而第二种方式只是重启RabbitMQ 应用。两种方式都可以从网络分区中恢复，但是更加推荐使用第二种方式，包括后面的自动处理网络分区的方式，其内部是采用的第二种方式进行重启节点。</p>
<h3 id="重启的顺序有何考究？"><a href="#重启的顺序有何考究？" class="headerlink" title="重启的顺序有何考究？"></a>重启的顺序有何考究？</h3><p>RabbitMQ 的重启顺序也比较讲究，必须在以下两种重启顺序中择其一进行重启操作：</p>
<ol>
<li>停止其他非信任分区中的所有节点，然后再启动这些节点。如果此时还有网络分区的告警，则再重启信任分区中的节点以去除告警。</li>
<li>关闭整个集群中的节点，然后再启动每一个节点，这里需要确保启动的第一个节点在<br>信任的分区之中。</li>
</ol>
<p>在选择哪种重启顺序之前 首先考虑一下队列“漂移”的现象。所谓的队列“漂移”是在配置镜像队列的情况下才会发生的。在配置镜像的集群中重启会有队列“漂移”的情况发生，造成负载不均衡。</p>
<blockquote>
<p>注意：一定要按照前面提及的两种方式择其一进行重启，如果选择挨个节点重启的方式，同样可以处理网络分区，但是这里会有一个严重的问题，即Mnesia 内容权限的归属问题。比如有两个分区[node1,node2] [node3,node4]，其中[node1,node2] 为信任分区，此时若按照挨个重启的方式进行重启，比如先重启node3 ，在node3 节点启动之时无法判断其节点的Mnesia 内容是向[node1,node2] 分区靠齐还是向node4 节点靠齐，至此，如果挨个一轮重启之后，最终集群中的Mnesia 数据是[node3 node4] 这个非信任分区，就会造成无法估量的损失。挨个节点重启也有可能会引起二次网络分区的发生。</p>
</blockquote>
<p>如果原本配置了镜像队列，从发生网络分区到恢复的过程中队列可能会出现“漂移”的现象。可以重启之前先删除镜像队列的配置，这样能够在一定程度上阻止队列的“过分漂移”，即阻止可能所有队列都“漂移”到一个节点上的情况。</p>
<p>删除镜像队列的配置可以采用 rabbitmqctl 工具删除：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl clear_policy [-p vhost] {mirror_queue_name}</span><br></pre></td></tr></tbody></table></figure>
<p>可以通过 Web 管理界面进行删除，也可以通过 HTTPAPI 的方式进行删除:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -u {username:password} -X DELETE http://localhost:15672/api/policies/default/{mirror_queue_name}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="网络分区处理步骤"><a href="#网络分区处理步骤" class="headerlink" title="网络分区处理步骤"></a>网络分区处理步骤</h3><ul>
<li>步骤 1：挂起生产者和消费者进程。这样可以减少消息不必要的丢失，如果进程数过多，情形又比较紧急，也可跳过此步骤。</li>
<li>步骤 2：删除镜像队列的配置。</li>
<li>步骤 3：挑选信任分区。</li>
<li>步骤 4：关闭非信任分区中的节点。采用 <code>rabbitmqctl stop_app</code> 命令关闭。</li>
<li>步骤 5：启动非信任分区中的节点。采用与步骤4 对应的 <code>rabbitmqctl start_app</code> 命令启动。</li>
<li>步骤 6：检查网络分区是否恢复，如果已经恢复则转步骤8，如果还有网络分区的报警则转步骤7。</li>
<li>步骤 7：重启信任分区中的节点。</li>
<li>步骤 8：添加镜像队列的配置。</li>
<li>步骤 9：恢复生产者和消费者的进程。</li>
</ul>
<h2 id="自动处理网络分区"><a href="#自动处理网络分区" class="headerlink" title="自动处理网络分区"></a>自动处理网络分区</h2><p>RabbitMQ 提供了三种方法自动地处理网络分区pause-minority 模式、pause-if-all-down 模式和autoheal 模式。默认是 ignore 模式，即不自动处理网络分区，所以在这种模式下，当网络分区的时候需要人工介入。在 rabbitmq.config 配置文件中配置<code>cluster_partition_handling</code> 参数即可实现相应的功能。默认的 ignore 模式的配置如下，注意最后有个点号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, ignore}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pause-minority-模式"><a href="#pause-minority-模式" class="headerlink" title="pause-minority 模式"></a>pause-minority 模式</h3><p>在pause-minority 模式下，当发生网络分区时，集群中的节点在观察到某些节点”down”的时候，会自动检测其自身是否处于”少数派”(分区中的节点小于或者等于集群中一半的节点数)，RabbitMQ 会自动关闭这些节点的运作。根据 CAP 原理，这里保障了P，即分区耐受性。这样确保了在发生网络分区的情况下，大多数节点(当然这些节点得在同一个分区中)可以继续运行。”少数派”中的节点在分区开始时会关闭，当分区结束时又会启动。这里关闭是指RabbitMQ 应用的关闭，而Erlang 虚拟机并不关闭，类似于执行了 <code>rabbitmqctl stop_app</code> 命令。处于关闭的节点会每秒检测一次是否可连通到剩余集群中，如果可以则启动自身的应用。相当于执行 <code>rabbitmqctl start_app</code> 命令。</p>
<p>pause-minority 模式相应的配置如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, pause-minority}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是RabbitMQ 会关闭不是严格意义上的大多数，比如在一个集群中只有两个节点的时候并不适合采用pause-minority 的模式，因为其中任何一个节点失败而发生网络分区时，两个节点都会关闭。当网络恢复时有可能两个节点会自动启动恢复网络分区，也有可能仍保持关闭状态，然而如果集群中的节点数远大于2 个时，pause-minority 模式比 ignore 模式更加可靠，特别是网络分区通常是由单节点网络故障而脱离原有分区引起的。</p>
<p>当对等分区出现时，会关闭这些分区内的所有节点，对于前面的[node1,node2] [node3,node4] 的例子而言，这四个节点上的RabbitMQ 应用都会被关闭，只有等待网络恢复之后，才会自动启动所有的节点以求从网络分区中恢复。</p>
<h3 id="pause-if-all-down-模式"><a href="#pause-if-all-down-模式" class="headerlink" title="pause-if-all-down 模式"></a>pause-if-all-down 模式</h3><p>在pause-if-all-down 模式下，RabbitMQ 集群中的节点在和所配置的列表中的任何节点不能交互时才会关闭 语法为 {pause_if_all_down, [nodes], ignore|autoheal}，其中[nodes]为受信节点，参考配置如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, {pause_if_all_down, ['rabbit@node1'], ignore}}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个节点与 rabbit@node1 节点无法通信时，则会关闭自身的 RabbitMQ 应用。如果是rabbit@node1 本身发生了故障造成网络不可用，而其他节点都是正常的情况下，这种规则会让所有的节点中 RabbitMQ 应用都关闭，待rabbit@node1 中的网络恢复之后，各个节点再启动自身应用以从网络分区中恢复。</p>
<p>pause-if-all-down 模式下有ignore 和autoheal 两种不同的配置。考虑前面pause-minority 模式中提及的一种情形，node1、node2 部署在机架A 上，而node3、node4 部署在机架B，此时配置{cluster_partition_handling,{pause_if_all_down,[‘rabbit@node1’ ,‘rabbit@node3’], ignore}}，那么当机架A 和机架B 通信出现异常时，由于node1、node2 保持着通信，node3、node4 保持着通信，这4 个节点都不会自行关闭，但是会形成两个分区，所以这样不能实现自动处理的功能。所以如果将配置中的ignore 替换成autoheal 就可以处理此种情形。</p>
<h3 id="autoheal-模式"><a href="#autoheal-模式" class="headerlink" title="autoheal 模式"></a>autoheal 模式</h3><p>在autoheal 模式下，当认为发生网络分区时，RabbitMQ 会自动决定一个获胜(winning)的分区，然后重启不在这个分区中的节点来从网络分区中恢复。一个获胜的分区是指客户端连接最多的分区，如果产生一个平局，即有两个或者多个分区的客户端连接数一样多，那么节点数最多的一个分区就是获胜分区，如果此时节点数也一样多，将以节点名称的字典序来挑选获胜分区。</p>
<p>autoheal 模式参考配置如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, autoheal}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意：在autoheal 模式下，如果集群中有节点处于非运行状态，那么当发生网络分区的时候，将不会有任何自动处理的动作。</p>
</blockquote>
<h3 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h3><p>允许RabbitMQ 够自动处理网络分区并不一定会有正面的成效，也有可能会带来更多的问题。网络分区会导致RabbitMQ 集群产生众多的问题，需要对遇到的问题做出一定的选择。如果置RabbitMQ 于一个不可靠的网络环境下，需要使用Federation 或者Shovel。就算从网络分区中恢复了之后，也要谨防发生二次网络分区。</p>
<p>每种模式都有自身的优缺点，没有哪种模式是万无一失的，要根据实际情形做出相应的选择，下面简要概论以下4 个模式：</p>
<ul>
<li>ignore 模式：发生网络分区时，不做任何动作，需要人工介入；</li>
<li>pause-minority 模式：对于对等分区的处理不够优雅，可能会关闭所有的节点。一般情况下，可应用于非跨机架、奇数节点数的集群中；</li>
<li>pause-if-all-down 模式：对于受信节点的选择尤为考究，尤其是在集群中所有节点硬件配置相同的情况下。此种模式可以处理对等分区的情形；</li>
<li>autoheal 模式：可以处于各个情形下的网络分区。但是如果集群中有节点处于非运行状态，则此种模式会失效；</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><h3 id="Firehose"><a href="#Firehose" class="headerlink" title="Firehose"></a>Firehose</h3><p>在RabbitMQ 中可以使用Firehose 功能来实现消息追踪，Firehose 可以记录每一次发送或者<br>消费消息的记录，方便RabbitMQ 的使用者进行调试、排错等。</p>
<p>开启Firehose 命令: <code>rabbitmqctl trace_on [-p vhost]</code> 其中 [-p vhost] 是可选参数用来指定虚拟主机vhost 。对应的关闭命令为 <code>rabbitmqctl trace_off [-p vhost]</code>。</p>
<p>Firehose 默认情况下处于关闭状态，并且Firehose 的状态也是非持久化的，会在RabbitMQ 服务重启的时候还原成默认的状态。Firehose 开启之后多少会影响RabbitMQ 整体服务的性能，因为它会引起额外的消息生成、路由和存储。</p>
<h3 id="rabbitmq-tracing-插件"><a href="#rabbitmq-tracing-插件" class="headerlink" title="rabbitmq_tracing 插件"></a>rabbitmq_tracing 插件</h3><p>rabbitrnq_tracing 插件相当于Firehose 的GUI 版本，它同样能跟踪RabbitMQ 中消息的流入流出情况。rabbitrnq_tracing 插件同样会对流入流出的消息进行封装，然后将封装后的消息日志存入相应的trace 文件之中。</p>
<p>可以使用<code>rabbitmq-plugins enable rabbitrnq_tracing</code> 命令来启动rabbitmq_tracing 插件。对应的关闭插件的命令是 <code>rabbitrnq-plugins disable rabbitrnq_tracing</code>。</p>
<p>开启后在Web 管理界面会多Tracing 页签。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li><p>客户端内部实现负载均衡</p>
</li>
<li><p>使用HAProxy实现负载均衡</p>
</li>
<li><p>使用Keepalived实现高可靠负载均衡</p>
</li>
<li><p>使用Keepalived+LVS实现负载均衡</p>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Haif.
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://haif.fun/2020/12/26/rabbitmq-4/" title="RabbitMQ 网络分区&amp;扩展">https://haif.fun/2020/12/26/rabbitmq-4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/RabbitMQ/" rel="tag"><i class="fa fa-tag"></i> RabbitMQ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/26/rabbitmq-3/" rel="prev" title="RabbitMQ 存储&告警&流控&镜像队列">
      <i class="fa fa-chevron-left"></i> RabbitMQ 存储&告警&流控&镜像队列
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/26/jvm-1/" rel="next" title="【JVM】：类从加载、连接、初始化到卸载">
      【JVM】：类从加载、连接、初始化到卸载 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="nav-number">1.</span> <span class="nav-text">网络分区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%84%8F%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">网络分区意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%88%A4%E5%AE%9A"><span class="nav-number">1.2.</span> <span class="nav-text">网络分区判定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="nav-number">1.3.</span> <span class="nav-text">模拟网络分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.4.</span> <span class="nav-text">网络分区的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">未配置镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">已配置镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">手动处理网络分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E4%BF%A1%E4%BB%BB%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">如何挑选信任分区？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E5%90%AF%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">如何重启节点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%90%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9C%89%E4%BD%95%E8%80%83%E7%A9%B6%EF%BC%9F"><span class="nav-number">1.5.3.</span> <span class="nav-text">重启的顺序有何考究？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.5.4.</span> <span class="nav-text">网络分区处理步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="nav-number">1.6.</span> <span class="nav-text">自动处理网络分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pause-minority-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">pause-minority 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pause-if-all-down-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">pause-if-all-down 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoheal-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.3.</span> <span class="nav-text">autoheal 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="nav-number">1.6.4.</span> <span class="nav-text">模式选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">2.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA"><span class="nav-number">2.1.</span> <span class="nav-text">消息追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Firehose"><span class="nav-number">2.1.1.</span> <span class="nav-text">Firehose</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rabbitmq-tracing-%E6%8F%92%E4%BB%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">rabbitmq_tracing 插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">2.2.</span> <span class="nav-text">负载均衡</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="HAIF."
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">HAIF.</p>
  <div class="site-description" itemprop="description">山行野宿， 孤身万里。<br/></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HAIF.</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : false,
      appId      : 'masttnqEt9G69mj43i9oaA1C-gzGzoHsz',
      appKey     : 'hgIx9VKn0GLDhRcLxQuNMl0E',
      placeholder: ":)",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://leancloud.haif.fun'
    });
  }, window.Valine);
});
</script>

</body>
</html>
